=\=\=\=\=\=\=
<<<<<<<=HEAD
>>>>>>>=01d2be1c2bee03c3a6a93356ad593b78a3ab5d9f
cmdhistory=["clojure.main" "server-start" "noir_video.server-start" "noir_video.server" "-main" "start" "clojure.main" "-main" "noir_video" "noir_video.server" "(noir_video.server)" "(noir-video.server)" "ns noir_video" "(ns my-app\\n  (\:use noir.core)\\n  (\:require [noir.server \:as server]))\\n\\n(defpage \\"/welcome\\" []\\n    \\"Welcome to Noir\!\\")\\n\\n(server/start 8080)" "(noir.server/start)" "(noir_video.server/-main)" "(noir.server/start)" "(noir_video.server/-main)" "noir_video.server/-main" "(noir_video/-main)" "(noir_video.server/-main)" "(defn all-videos [{\:id \\"Video1\\"\\n              \:title \\"Sample Video\\"\\n              \:path \\"lib/web.mp4\\"}])" "noir_video.server/-main" "(noir_video.server/-main)" "lein deps" "(noir_video.server)" "(noir_video.server/load-views-ns 'noir_video.views)" "(noir_video.server/start)" "(noir_video.server/-main)" "(noir_video.models.user/login\! {\:username \\"subhash\\"})" "(noir_video.server/-main)" "(noir_video.models.user/logged-in?)" "(noir_video.server/-main)" "(use '[datomic.api \:only [q db] \:as d])\\n(use 'clojure.pprint)\\n\\n;; store database uri\\n(def uri \\"datomic\:mem\://seattle\\")\\n\\n;; create database\\n(d/create-database uri)\\n\\n;; connect to database\\n(def conn (d/connect uri))" "(def schema-tx (read-string (slurp \\"src/noir_video/schema/noir-video-schema.dtm\\")))" "(first schema-tx)" "@(d/transact conn schema-tx)" "\\n;; parse seed data dtm file\\n(def data-tx (read-string (slurp \\"src/noir_video/schema/noir-video-data.dtm\\")))\\n\\n;; display first three statements in seed data transaction\\n(first data-tx)\\n(second data-tx)\\n(nth data-tx 2)" ";; submit seed data transaction\\n@(d/transact conn data-tx)" ";; parse seed data dtm file\\n(def data-tx (read-string (slurp \\"src/noir_video/schema/noir-video-data.dtm\\")))\\n\\n;; display first three statements in seed data transaction\\n(first data-tx)\\n(second data-tx)\\n(nth data-tx 2)\\n\\n;; submit seed data transaction\\n@(d/transact conn data-tx)" ";; find all actors, return entity ids\\n(def results (q '[\:find ?a \:where [?a \:action/actor]] (db conn)))\\n(count results)" ";; get first entity id in results and make an entity map\\n(def id (ffirst results))\\n(def entity (-> conn db (d/entity id)))" "(keys entity)" "(\:action/actor entity)" "(+ 2 3)" "\\n(use '[datomic.api \:only [q db] \:as d])\\n(use 'clojure.pprint)\\n\\n;; store database uri\\n(def uri \\"datomic\:mem\://seattle\\")\\n\\n;; create database\\n(d/create-database uri)\\n\\n;; connect to database\\n(def conn (d/connect uri))\\n\\n;; parse schema dtm file\\n(def schema-tx (read-string (slurp \\"src/noir_video/schema/noir-video-schema.dtm\\")))\\n\\n;; display first statement\\n(first schema-tx)\\n\\n;; submit schema transaction\\n@(d/transact conn schema-tx)\\n\\n;; parse seed data dtm file\\n(def data-tx (read-string (slurp \\"src/noir_video/schema/noir-video-data.dtm\\")))\\n\\n;; display first three statements in seed data transaction\\n(first data-tx)\\n(second data-tx)\\n(nth data-tx 2)" "@(d/transact conn data-tx)\\n\\n;; find all actors, return entity ids\\n(def results (q '[\:find ?a \:where [?a \:action/actor]] (db conn)))\\n(count results)" "(def results (q '[\:find ?a \:where [?a \:user/name]] (db conn)))\\n(count results)" "@(d/transact conn data-tx)" "\\n(use '[datomic.api \:only [q db] \:as d])\\n(use 'clojure.pprint)\\n\\n;; store database uri\\n(def uri \\"datomic\:mem\://seattle\\")\\n\\n;; create database\\n(d/create-database uri)\\n\\n;; connect to database\\n(def conn (d/connect uri))\\n\\n;; parse schema dtm file\\n(def schema-tx (read-string (slurp \\"src/noir_video/schema/noir-video-schema.dtm\\")))\\n\\n;; display first statement\\n(first schema-tx)\\n\\n;; submit schema transaction\\n@(d/transact conn schema-tx)" "(def data-tx (read-string (slurp \\"src/noir_video/schema/noir-video-data.dtm\\")))\\n\\n;; display first three statements in seed data transaction\\n(first data-tx)\\n(second data-tx)\\n(nth data-tx 2)\\n\\n;; submit seed data transaction\\n@(d/transact conn data-tx)" "(use '[datomic.api \:only [q db] \:as d])\\n(use 'clojure.pprint)\\n\\n;; store database uri\\n(def uri \\"datomic\:mem\://seattle\\")\\n\\n;; create database\\n(d/create-database uri)\\n\\n;; connect to database\\n(def conn (d/connect uri))\\n\\n;; parse schema dtm file\\n(def schema-tx (read-string (slurp \\"src/noir_video/schema/noir-video-schema.dtm\\")))\\n\\n;; display first statement\\n(first schema-tx)\\n\\n;; submit schema transaction\\n@(d/transact conn schema-tx)" ";; parse seed data dtm file\\n(def data-tx (read-string (slurp \\"src/noir_video/schema/noir-video-data.dtm\\")))\\n\\n;; display first three statements in seed data transaction\\n(first data-tx)\\n(second data-tx)\\n(nth data-tx 2)\\n\\n;; submit seed data transaction\\n@(d/transact conn data-tx)" ";; find all users, return entity ids\\n(def results (q '[\:find ?a \:where [?a \:user/name]] (db conn)))\\n(count results)" ";; get first entity id in results and make an entity map\\n(def id (ffirst results))\\n(def entity (-> conn db (d/entity id)))\\n\\n;; display the entity map's keys\\n(keys entity)\\n\\n;; display the value of the action's actor name\\n(\:action/actor entity)" "(\:user/name entity)" "(let [db (db conn)]\\n  (pprint (map \#(\:user/name (d/entity db (first %))) results)))" "(first [1,2,3])" "entity" "(\:action/_actor entity)" "(def by_subhash (\:action/_actor entity))" "(count by_subhash)" "(pprint (map \#(\:action/object (d/entity (db conn) %)) by_subhash))" "(pprint (map \#(\:action/object (d/entity (db conn) (first %))) by_subhash))" "(def db (db conn))" "db" "by_subhash" "(map (%) by_subhash)" "(map \#(%) by_subhash)" "(map \#(d/entity %) by_subhash)" "(map \#(d/entity db %) by_subhash)" "(map \#(d/entity db (first %)) by_subhash)" "(map \#(pprint %) by_subhash)" "(db conn)" "(map \#(d/entity (db conn) (first %)) by_subhash)" "(map \#(\:action/type (d/entity (db conn) (first %))) by_subhash)" " (map \#(\:action/object (d/entity (db conn) (first %))) by_subhash)" "(def all_actions (q '[\:find ?a \:where [?a \:action/type]] (db conn)))\\n(let [db (db conn)]\\n  (pprint (map \#(\:action/type (d/entity db (first %))) all_actions)))" "(let [db (db conn)]\\n  (pprint (map \#(\:action/actor (d/entity db (first %))) all_actions)))" "(noir_video.server/-main)" "noir_video.models/conn" "(datomic.db (noir_video.models/conn))" "(d/transact n/conn [[\\"db/add\\" (d/tempid \\"db.part/user\\") \\"user/name\\" \\"subhash\\"]])" "(ns myspace (\:require [datomic.api \:as d]))" "(d/transact n/conn [[\\"db/add\\" (d/tempid \\"db.part/user\\") \\"user/name\\" \\"subhash\\"]])" "(ns myspace (\:require [datomic.api \:as d][noir_video.models \:as n]))" " (d/transact n/conn [[\\"db/add\\" (d/tempid \\"db.part/user\\") \\"user/name\\" \\"subhash\\"]])" "(def results (q '[\:find ?u where [?u \:user/name]]) (n/conn))" "(def results (q '[\:find ?u where [?u \:user/name]]) n/conn)" "(def res (q '[\:find ?u where [?u \:user/name]]) n/conn)" "(def res (q '[\:find ?u where [?u \:user/name]]) (d/db n/conn))" "(noir_video.server/-main)" "(+ 1 2)" "(noir_video.server/-main)" "(ns noir_video.models.user  \\n  (\:require [noir.session \:as session]\\n            [datomic.api \:as d]\\n            [noir_video.models \:as n]))" "  (def results (d/q '[\:find ?u ?n \:where [?u \:user/name ?n]] (d/db n/conn)))" "(count results)" "(pprint results)" "  (def results (d/q '[\:find ?u  \:where [?u \:user/name \\"subhash\\"]] (d/db n/conn)))" "(pprint results)" "  (def results (d/q '[\:find ?u  \:where [?u \:user/name \\"blaine\\"]] (d/db n/conn)))" "(pprint results)" "(first results)" "(ffirst results)" "  (def results (d/q '[\:find ?u  \:where [?u \:user/name \\"subhash\\"]] (d/db n/conn)))" "(first results)" "(ffirst results)" "(def a null)" "(def a (first []))" "a" "if" "(if a (true) (false))" "(if a true false)" "(if (not a) true false)" "(noir_video.server/-main)" "(ns noir_video.models.user  \\n  (\:require [noir.session \:as session]\\n            [datomic.api \:as d]\\n            [noir_video.models \:as n]))" "      (def results (d/q '[\:find ?u \:where [?u \:user/name \\"subhash\\"]] (d/db n/conn)))" "(pprint results)" "(ffirst results)" "(def s (pprint results))" "(noir_video.server/-main)" "(myspace/foo)" "(with-out-str (println \\"this should return as a string\\"))" "(noir_video.server/-main)" "\\"sdsd\\"+\\"Sdsd\\"" "(+ \\"Aas\\" \\"ASA\\")" "(concat \\"Aas\\" \\"ASA\\")" "'[\:find ?u  \:where [?u \:user/name username]]" "(noir_video.server/-main)" "username" "(def username \\"sdsd\\")" "username" "'[\:find ?u  \:where [?u \:user/name ~username]]" "(clojure.core/unquote username)" "(clojure.core/unquote 'username)" "'[\:find ?u  \:where [?u \:user/name ~(username)]]" "'[\:find ?u  \:where [?u \:user/name ~(eval username)]]" "(use '[datomic.api \:only [q db] \:as d])\\n(use 'clojure.pprint)\\n\\n;; store database uri\\n(def uri \\"datomic\:mem\://seattle\\")\\n\\n;; create database\\n(d/create-database uri)\\n\\n;; connect to database\\n(def conn (d/connect uri))\\n\\n;; parse schema dtm file\\n(def schema-tx (read-string (slurp \\"src/noir_video/schema/noir-video-schema.dtm\\")))\\n\\n;; display first statement\\n(first schema-tx)\\n\\n;; submit schema transaction\\n@(d/transact conn schema-tx)\\n\\n;; parse seed data dtm file\\n(def data-tx (read-string (slurp \\"src/noir_video/schema/noir-video-data.dtm\\")))\\n\\n;; display first three statements in seed data transaction\\n(first data-tx)\\n(second data-tx)\\n(nth data-tx 2)\\n\\n;; submit seed data transaction\\n@(d/transact conn data-tx)\\n\\n;; find all users, return entity ids\\n(def results (q '[\:find ?a \:where [?a \:user/name]] (db conn)))\\n(count results)\\n\\n;; get first entity id in results and make an entity map\\n(def id (ffirst results))\\n(def entity (-> conn db (d/entity id)))\\n\\n;; display the entity map's keys\\n(keys entity)\\n\\n;; display the value of the action's actor name\\n(\:user/name entity)" "(count results)" "(q '[\:find ?a \:where [?a \:user/name 'subhash']] (db conn))" "(q '[\:find ?a \:where [?a \:user/name subhash]] (db conn))" "(q '[\:find ?a \:where [?a \:user/name \\"subhash\\"]] (db conn))" "username" "(def username \\"subhash\\")" "username" "(q '[\:find ?a \:where [?a \:user/name ~username]] (db conn))" "(q '[\:find ?a \:where [?a \:user/name \\"~username\\"]] (db conn))" "(q '[\:find ?a \:where [?a \:user/name (eval username)]] (db conn))" "(q '[\:find ?a \:where [?a \:user/name ~(eval username)]] (db conn))" "(q \\"\:find ?a \:where ?a \:user/name \\\\\\"subhash\\\\\\"\\" (db conn))" "(q \\"\:find ?a \:where ?a \:user/name\\" (db conn))" "(q \\"\:find ?a \:where [?a \:user/name]\\" (db conn))" "(q \\"[\:find ?c \:where [?c \:user/name]]\\" (db conn))" "(q \\"[\:find ?c \:where [?c \:user/name subhash]]\\" (db conn))" "(q \\"[\:find ?c \:where [?c \:user/name 'subhash']]\\" (db conn))" "(q \\"[\:find ?c \:where [?c \:user/name \\"subhash\\"]]\\" (db conn))" "(q \\"[\:find ?c \:where [?c \:user/name \\\\\\"subhash\\\\\\"]]\\" (db conn))" "(join \\"sds\\" \\"sss\\")" "(clojure.string/join \\"sdsd\\" \\"sss\\")" "(q (clojure.string/join \\"[\:find ?c \:where [?c \:user/name \\" (clojure.string/join username \\"]]\\")) (db conn))" "(clojure.string/join \\"[\:find ?c \:where [?c \:user/name \\" (clojure.string/join username \\"]]\\"))" "username" "(clojure.string/join username \\"]]\\")" "(def username \\"subhash\\")" "username" "(q \\"\:find ?a \:where [?a \:user/name]\\" (db conn))" "(q '[\:find ?a \:where [?a \:user/name \\"subhash\\"]] (db conn))" "(q '[\:find ?a \:where [?a \:user/name 'subhash']] (db conn))" "'[\:find ?u  \:where [?u \:user/name ~(username)]]" "(noir_video.server/-main)" "(use '[datomic.api \:only [q db] \:as d])\\n(use 'clojure.pprint)\\n\\n;; store database uri\\n(def uri \\"datomic\:mem\://seattle\\")\\n\\n;; create database\\n(d/create-database uri)\\n\\n;; connect to database\\n(def conn (d/connect uri))\\n\\n;; parse schema dtm file\\n(def schema-tx (read-string (slurp \\"src/noir_video/schema/noir-video-schema.dtm\\")))\\n\\n;; display first statement\\n(first schema-tx)\\n\\n;; submit schema transaction\\n@(d/transact conn schema-tx)\\n\\n;; parse seed data dtm file\\n(def data-tx (read-string (slurp \\"src/noir_video/schema/noir-video-data.dtm\\")))\\n\\n;; display first three statements in seed data transaction\\n(first data-tx)\\n(second data-tx)\\n(nth data-tx 2)\\n\\n;; submit seed data transaction\\n@(d/transact conn data-tx)\\n\\n;; find all users, return entity ids\\n(def results (q '[\:find ?a \:where [?a \:user/name]] (db conn)))\\n(count results)\\n\\n;; get first entity id in results and make an entity map\\n(def id (ffirst results))\\n(def entity (-> conn db (d/entity id)))\\n\\n;; display the entity map's keys\\n(keys entity)\\n\\n;; display the value of the action's actor name\\n(\:user/name entity)\\n\\n;; for each user, display their name\\n(let [db (db conn)]\\n  (pprint (map \#(\:user/name (d/entity db (first %))) results)))\\n\\n(def all_actions (q '[\:find ?a \:where [?a \:action/type]] (db conn)))\\n(let [db (db conn)]\\n  (pprint (map \#(\:action/actor (d/entity db (first %))) all_actions)))" "(ffirst all_actions)" "(entity (ffirst all_actions))" "(def e (entity (ffirst all_actions)))" "(d/entity (ffirst all_actions))" "(def id (ffirst all_actions))" "(d/entity id)" "(d/entity id (db conn))" "(d/entity id db)" "(d/entity id (d/db conn))" "all_actions" "(d/transact n/conn [[\\"db/add\\" (d/tempid \\"db.part/user\\") \\"action/actor\\" 17592186045420 \\"action/type\\" \\"action.type/play\\"]])" "conn" "(d/transact conn [[\\"db/add\\" (d/tempid \\"db.part/user\\") \\"action/actor\\" 17592186045420 \\"action/type\\" \\"action.type/play\\"]])" "(count all_actions)" "(def all_actions (q '[\:find ?a \:where [?a \:action/type]] (db conn)))\\n(let [db (db conn)]\\n  (pprint (map \#(\:action/actor (d/entity db (first %))) all_actions)))" "(def r (q '[\:find ?a \:where [?a \:user/name]] (db conn)))" "(pprint r)" "(def s (pprint r))" "(def s (println r))" "s" "(def s (pprint r))" "s" "(noir_video.server/-main)" "(def all_users (q '[\:find ?u \:where [?u \:user/name]] (db conn)))" "(def all_users (d/q '[\:find ?u \:where [?u \:user/name]] (db conn)))" "(ns noir_video.models.user  \\n  (\:require [noir.session \:as session]\\n            [datomic.api \:as d]\\n            [noir_video.models \:as n]))" "(def all_users (q '[\:find ?u \:where [?u \:user/name]] (db conn)))" "(def all_users (d/q '[\:find ?u \:where [?u \:user/name]] (d/db n/conn)))" "(pprint all_users)" "(def all_users (d/q '[\:find ?n \:where [?u \:user/name ?n]] (d/db n/conn)))" "(pprint all_users)" "(apply + [1,2])" "(apply + [1,2, 3])" "(apply str [\\"ssd\\", \\"eee\\"])" "(apply (str % \\",\\") [\\"ssd\\", \\"eee\\"])" "(apply \#(str % \\",\\") [\\"ssd\\", \\"eee\\"])" "(apply (str \\",\\") [\\"ssd\\", \\"eee\\"])" "(def all_users (d/q '[\:find ?v ?t \:where [?v \:video/title ?t]] (d/db n/conn)))" "(pprint all_users)" "(seq all_users)" "(interpose \\",\\" [\\"dsd\\", \\"sdsd\\", \\"eee\\"])" "(noir_video.models.user/data)" "(noir_video.server/-main)" "(use '[datomic.api \:only [q db] \:as d])\\n(use 'clojure.pprint)\\n\\n;; store database uri\\n(def uri \\"datomic\:mem\://seattle\\")\\n\\n;; create database\\n(d/create-database uri)\\n\\n;; connect to database\\n(def conn (d/connect uri))\\n\\n;; parse schema dtm file\\n(def schema-tx (read-string (slurp \\"src/noir_video/schema/noir-video-schema.dtm\\")))\\n\\n;; display first statement\\n(first schema-tx)\\n\\n;; submit schema transaction\\n@(d/transact conn schema-tx)\\n\\n;; parse seed data dtm file\\n(def data-tx (read-string (slurp \\"src/noir_video/schema/noir-video-data.dtm\\")))\\n\\n;; display first three statements in seed data transaction\\n(first data-tx)\\n(second data-tx)\\n(nth data-tx 2)\\n\\n;; submit seed data transaction\\n@(d/transact conn data-tx)\\n\\n;; find all users, return entity ids\\n(def results (q '[\:find ?a \:where [?a \:user/name]] (db conn)))\\n(count results)\\n\\n;; get first entity id in results and make an entity map\\n(def id (ffirst results))\\n(def entity (-> conn db (d/entity id)))\\n\\n;; display the entity map's keys\\n(keys entity)\\n\\n;; display the value of the action's actor name\\n(\:user/name entity)\\n\\n;; for each user, display their name\\n(let [db (db conn)]\\n  (pprint (map \#(\:user/name (d/entity db (first %))) results)))\\n\\n(def all_actions (q '[\:find ?a \:where [?a \:action/type]] (db conn)))\\n(let [db (db conn)]\\n  (pprint (map \#(\:action/actor (d/entity db (first %))) all_actions)))" "(def all_actions (d/q '[\:find ?n ?t \:where [?a \:action/type ?t] [\:action/actor ?u] [?u \:user/name ?n]] (d/db n/conn)))" "(ns noir_video.models.user  \\n  (\:require [noir.session \:as session]\\n            [datomic.api \:as d]\\n            [noir_video.models \:as n]))" "(def all_actions (d/q '[\:find ?n ?t \:where [?a \:action/type ?t] [\:action/actor ?u] [?u \:user/name ?n]] (d/db n/conn)))" "(pprint all_actions)" "(pprint (d/q '[\:find ?u ?t \:where [?a \:action/type ?t] [\:action/actor ?u]] (d/db n/conn)))" "(pprint (d/q '[\:find ?n ?t \:where [?a \:action/type ?t] [\:action/actor ?u] [?u \:user/name ?n]] (d/db n/conn)))" "(pprint (d/q '[\:find ?u ?n \:where  [?u \:user/name ?n]] (d/db n/conn)))" "(pprint (d/q '[\:find ?u ?n \:where  [?u \:user/name \\"subhash\\"]] (d/db n/conn)))" "(def results (d/q '[\:find ?u ?n \:where  [?u \:user/name \\"subhash\\"]] (d/db n/conn)))" "(ffirst results)" "(pprint (d/q '[\:find ?u ?t \:where [?a \:action/type ?t] [?a \:action/actor ?u]] (d/db n/conn)))" "(pprint (d/q '[\:find ?n ?t \:where [?a \:action/type ?t] [?a \:action/actor ?u] [?u \:user/name ?n]] (d/db n/conn)))" ";(def videos (d/q '[\:find ?v ?t \:where [?v \:video/title ?t]] (d/db n/conn)))" "(def videos (d/q '[\:find ?v ?t \:where [?v \:video/title ?t]] (d/db n/conn)))" "(pprint videos)" "(ffirst videos)" "(first videos)" "(pprint (first videos))" "a \= (first videos)" "(def a (first videos))" "(first a)" "(second a)" "(defn foo[a] (first a))" "(foo videos)" "(map foo videos)" "videos" "(defn get_item[a] ({\:title (second a)}))" "(map get_items videos)" "(map get_item videos)" "videos" "(seq videos)" "videos" "(defn get_item[a] ({\:title (second a)}))" "(map get_item (seq videos))" "(defn get_item[a] ([(second a)]))" "(map get_item (seq videos))" "(map pprint (seq videos))" "(map println (seq videos))" "(map println (videos))" "(map println videos)" "foo" "(defn foo[a] (first a))" "(map foo videos)" "(defn foo[a] (second a))" "(map foo videos)" "(defn foo[a] {\:second (second a)})" "(map foo videos)" "(defn foo[a] {\:first (first a) \:second (second a)})" "(map foo videos)" "(def a (map foo videos))" "(list a)" "[1,2,3]" "(a [1,2,3])" "(def a [1,2,3])" "a" "(printl a)" "(type a)" "(def results (map foo videos))" "(type results)" "(list results)" "results" "(print results)" "(pprint results)" "results" "(map foo videos)" "(map println results)" "(first results)" "(second results)" "(def results (map foo videos))" "results" "(map println results)" "(defn foo[a] {\:id (first a) \:title (second a) \:path (str \\"/lib/\\" (second a))})" "(map foo videos)" "(map noir_video.views.common/video-item (map foo videos))" "(noir_video.models.video/all-videos)" "(noir_video.server/-main)" "(noir_video.models.video/all-videos)" "(noir_video.models.user/old)" "(noir_video.models.video/all-videos)" "(noir_video.server/-main)" "(noir_video.models.video/all-videos)" "(noir_video.models.video/old_videos)" "noir_video.models.video/old_videos" "(noir_video.models.video/all-videos)" "(seq (noir_video.models.video/all-videos))" "(noir_video.views.common/video-list (noir_video.models.video/all-videos))" "(noir_video.server/-main)"]
eclipse.preferences.version=1
